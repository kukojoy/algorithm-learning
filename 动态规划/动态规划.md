## 动态规划

**思想：**利用一维数组、二维数组等记录历史数据，利用历史数据可以快速进行递推，避免重复计算。

**第一步：**定义语义，例如使用一维数组dp[]保存历史数据，那么必须明确dp[i]的语义，比如在解决斐波那契数列问题时，dp[i]可规定为数列中第i个数的值。

**第二步：**找出数组dp[]中元素之间的关系，例如在斐波那契数列中，有dp[i] = dp[i - 1] + dp[i - 2]。

**第三步：**找出数组dp[]中初始就可确定的值，称为边界条件，例如在斐波那契数列中，有dp[0] = 0，dp[1] = 1

其中，第一步是最关键的，dp语义的确定决定了算法的可行性、实现难度和效率。第二步是最难的，状态转移公式必须符合语义逻辑。

## 案例

**问题一：**一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

第一步：定义dp[]，语义为跳上i级台阶共有dp[i]种跳法。

第二步，跳上第i级台阶，可以从第i - 1级台阶跳一次上来，也可以从第i - 2级跳一次上来，因此，dp[i] = dp[i - 1] + dp[i - 2]。

第三步，确定边界条件，dp[0] = 1，dp[1] = 2。

最后循环求解：

```python
dp = [0 for _ in range(n)]
dp[0] = 1
dp[1] = 2
for i in range(2, n):
	dp[i] = dp[i - 1] + dp[i - 2]
ans = dp[-1]
```

**注意：**状态的变换必须是一次的，例如，状态dp[i - 2]需要一步到达dp[i]，也就是从第i - 2级台阶一次变成i级，如果认为从第i - 2级可以有两种变成第i级的方法（跳两级或连跳两次一级），而认为dp[i] = dp[i - 1] + 2*dp[i - 2]，那么会造成冗余，因为dp[i - 1] 包括了dp[i - 2]连跳两次一级的那种情况。 dp[i] = dp[i - 1] - dp[i - 2] + 2 x dp[i - 2]。

在实际做题的过程中，绝大多数的动规数组都是二维的，至于使用一维、二维还是更高维度的动规数组，说到底取决于语义的选取。

**问题二：**一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？

第一步，定义dp，dp\[i][j]表示以坐标i，j为终点的网格的路径。

第二步，以dp\[i][j]为终点，机器人从上方或左方过来，路径数为dp\[i - 1][j] + dp\[i][j - 1]。

第三步，边界条件为dp的第0行和第0列均为1。

最后循环求解：

```python
dp = [[0 for _ in range(n)] for _ in range(m)]
for j in range(n):
	dp[0][j] = 1
for i in range(m):
	dp[i][0] = 1
for i in range(1, m):
	for j in range(1, n):
		dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
ans = dp[-1][-1]
```

实际上很多题的状态转移方程不是简单的递推式，而是需要求最优解，如最值问题，此时需要不断保持状态最优。

**问题三**：给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

第一步：定义dp，dp\[i][j]表示从原点到（i，j）的路径的最小和。

第二步，以dp\[i][j]为终点，从上方或左方过来，最小和为min(dp\[i - 1][j], dp\[i][j - 1]) + grid\[i][j]。

第三步，边界条件为dp的第0行和第0列为行/列的前缀和。

最后循环求解：

```python
dp = grid
for j in range(1, n):
	dp[0][j] += dp[0][j - 1]
for i in range(1, m):
	dp[i][0] += dp[i - 1][0]
for i in range(1, m):
	for j in range(1, n):
		dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + dp[i][j]
ans = dp[-1][-1]
```

有时候，语义的确定是比较难的，但也有套路可循，例如，题目需要的是什么样的答案，语义信息就是什么，dp数组的维度一般也与给出的输入有关，例如索引、位置信息，长度信息等。其次，状态转移方程很可能需要分类讨论，讨论的一般是i和j的相对关系，例如大小，或具体的计算关系，例如i == j + 1等，最后，确认边界条件。

**问题四：**给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：任意位置的插入、修改、删除。

例如：word1 = “horse”，word2 = “ros”，h -> r，r -> ''，e -> ''，共三步

第一步：定义dp，dp\[i][j]语义为将word1（长度为i）变成word2（长度为j）所需要的最少步骤。

第二步：定义转移方程。

假如word[i] == word[j]，则dp\[i][j] = dp\[i - 1][j - 1]。

假如word1[i] != word2[j]：

若将word1中的i - 1个字符修改为word2的j - 1个字符，再修改最后一个字符，则dp\[i][j] = dp\[i - 1][j - 1] + 1

若将word1中的i个字符修改为word2的j - 1个字符，再插入最后一个元素，则p\[i][j] = dp\[i][j - 1] + 1

若将word1中的i - 1个字符修改为word2的j个字符，再删除一个多余的元素，则p\[i][j] = dp\[i - 1][j] + 1

则dp\[i][j] = min(dp\[i - 1][j - 1], dp\[i][j - 1], dp\[i - 1][j]) + 1

第三步：确定边界条件，当i = 0或j = 0时，需要定义初始值，当i = 0时，只要插入j个字符，当j = 0时，只要删除i个字符。

```python
l1 = len(word1)
l2 = len(word2)

dp = [[0 for _ in range(l2 + 1)] for _ in range(l1 + 1)]

for i in range(l1 + 1):
	dp[i][0] = i
    
for j in range(l2 + 1):
	dp[0][j] = j

for i in range(1, l1 + 1):
	for j in range(1, l2 + 1):
        if word1[i - 1] == word2[j - 1]:
            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1])
        else:
			dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
            
ans = dp[l1][l2]
```

