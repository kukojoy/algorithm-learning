## 搜索

当问题的状态或解空间可以用有限个离散的数值表示，一般可以使用搜索技术解决。搜索是一种通用的方法，通常比较暴力，遍历所有可能的解，逐一检查判断从而找到答案。

搜索一般有一下操作步骤：

第一步，用数据结构（通常为数组、哈希表等，特别是二维数组）表示问题的状态或解空间。

第二步，从一个起始状态出发，寻找其他的状态，找到答案。

第三步，优化，尽可能排除不符合条件的数据，压缩搜索范围，或采用高效的查找算法。

**DFS：**深度优先搜索，逐渐搜索更深的节点，遍历当前节点的一个邻居，直接遍历邻居的邻居。

**BFS：**宽度优先搜索，一层一层递进，遍历完当前节点的全部邻居，才会遍历邻居的邻居。

## DFS模板

**1. 递归实现（代码量少，常用）**

```python
# 假设用一个二维数组表示解空间，索引[x][y]表示状态节点的索引
d = [[-1, 0], [0, 1], [1, 0], [0, -1]] # 上、右、下、左四个方向
def dfs(x, y):
    operate # 搜索到该状态时应该执行的操作
    for i in range(4): # 遍历四个方向
        nx, ny = x + d[i][0], y + d[i][1]
        if condition: # 若这个方向应该被搜索
        	dfs(nx, ny)
```

**2. 栈实现（与BFS队列模板相同，好记忆）**

```python
# 假设用一个二维数组表示解空间，索引[x][y]表示状态节点的索引
d = [[-1, 0], [0, 1], [1, 0], [0, -1]] # 上、右、下、左四个方向

def dfs():
    s = [] # 用Python列表实现栈，栈内元素为[x, y]
	s.append([start_x, start_y]) # 放入初始节点

    while s: # 栈不为空
        now_x, now_y = s[-1][0], s[-1][1]
        del s[-1] # 出栈
        
        operate # 搜索到该状态时应该执行的操作
        
        for i in range(4): # 遍历四个方向
            next_x, next_y = now_x + d[i][0], now_y + d[i][1]
             if condition: # 若这个方向应该被搜索
                s.append([next_x, next_y]) # 入栈
```

## BFS模板

**1. 队列实现（常用，与DFS栈实现模板相同）**

```python
# 假设用一个二维数组表示解空间，索引[x][y]表示状态节点的索引
d = [[-1, 0], [0, 1], [1, 0], [0, -1]] # 上、右、下、左四个方向

def bfs():
    q = [] # 用Python列表实现栈，栈内元素为[x, y]
	q.append([start_x, start_y]) # 放入初始节点

    while q: # 队不为空
        now_x, now_y = q[0][0], q[0][1]
        del q[0] # 出队
        
        operate # 搜索到该状态时应该执行的操作
        
        for i in range(4): # 遍历四个方向
            next_x, next_y = now_x + d[i][0], now_y + d[i][1]
             if condition: # 若这个方向应该被搜索
                q.append([next_x, next_y]) # 入队
```

