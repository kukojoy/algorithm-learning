## 概述

**定义：**并查集是一种树型的数据结构，用于处理元素的合并及查询问题（即并、查）

**主要构成：**一个整型数组pre[]，三个函数init()、find()、union()

**作用：**解决图的连通性问题，如判断两个节点是否可达、计算连通的分支数等

## pre[]数组的意义

**语义：**pre[]数组记录了节点的上一级，假如n是一个人，那么pre[n]是他的父亲，假如n是一个员工，那么pre[n]是他的组长。假如一个人的上一级就是他自己，即pre[n] == n，那么他就是最高级。

## init()函数

**语义：**对prep[]数组进行初始化，让每个节点各自为派

```python
def init(n) # 初始化函数，对全部的n个结点进行初始化 
    for i in range(n):
        pre[i] = i # 每个结点的上级都是自己 
        weight[i] = 1 # 每个结点构成的树的权值为1 
```

## find()函数

**语义：**find(n)用于查找节点n可向上追溯到的最高级节点，假如n是一个人，那么find(n)返回的是他的祖先，假如n是一个学生，那么find(n)返回的是他所在学校的校长。

```python
# Python代码实现：
def find(n):
    while(pre[n] != n): # 一个人的上级不是自己
  		n = pre[n] # 那么他变成他的上级，并继续向上寻找
    return n # 此时已经满足pre[n] == n
```

**路径压缩 --- find()函数的优化：**上面的find()函数每次通过循环，一级一级向上找到最高级，如果树的高度过高，那么查找的效率就很低，最好O(logn)，最差O(n)。因此，当一个节点n找到最高级时，可以让其的上一级直接替换为最高级，以后n下面的人要通过n找到最高级时，就可以直接找到，不用再循环向上。

```python
# 改进find()的具体实现
def find(n):
    if pre[n] == n: # 一个人的上级是自己，那么他就是最高级
        return n
    pre[n] = find(pre[n]) # 找到他上级的最高级，并让他的上级变成最高级
    return pre[n]
```

## union()函数

**语义：**union(n1, n2)用于合并两个互不相交的集合，其中n1，n2是任意两个人，假如n1和n2原本不属于一个集合，进行合并操作后，他们所在的两个集合将合并为一个。

```python
# Python代码实现
def union(n1, n2):
    root1 = find(n1) # 找到n1的头头
    root2 = find(n2) # 找到n2的头头
    if root1 != root2:
    	pre[root2] = root1 # 让root1成为root2的头头
```

**路径压缩 --- union()函数的优化（加权标记）：**在合并集合时，可以让帮派一的老大当帮派二的小弟，也可以让帮派二的老大当帮派一的小弟，到底怎么合并可以使合并后的集合进行后续的操作有更高的效率，可以为每个节点设置一个权值，比如这个权值就是以该节点为根的子树的高度，让高度小的树合并到高度大的树，这样可以使新树的高度尽量小，平衡性好。

```python
# 改进union()的具体实现
def union(n1, n2):
    root1 = find(n1) 
    root2 = find(n2)
    if weight[root1] > weight[root2]:
        pre[root2] = root1
    else:
        if weight[root1] == weight[root2]:
        	weight[root2] += 1
        pre[root1] = root2
```